{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.verifyToken=void 0;var _authError=_interopRequireDefault(require(\"../auth/authError\"));var _signatureVerifier=require(\"./signatureVerifier\");var DEFAULT_LEEWAY=60;var verifyToken=function verifyToken(idToken,options){if(typeof idToken!=='string'){return Promise.resolve();}return(0,_signatureVerifier.verifySignature)(idToken,{domain:options.domain}).then(function(payload){return validateClaims(payload,options);}).then(function(){return Promise.resolve();});};exports.verifyToken=verifyToken;var validateClaims=function validateClaims(payload,opts){if(typeof payload.iss!=='string'){return Promise.reject(idTokenError({error:'missing_issuer_claim',desc:'Issuer (iss) claim must be a string present in the ID token'}));}if(payload.iss!=='https://'+opts.domain+'/'){return Promise.reject(idTokenError({error:'invalid_issuer_claim',desc:\"Issuer (iss) claim mismatch in the ID token; expected \\\"https://\"+opts.domain+\"/\\\", found \\\"\"+payload.iss+\"\\\"\"}));}if(typeof payload.sub!=='string'){return Promise.reject(idTokenError({error:'missing_subject_claim',desc:'Subject (sub) claim must be a string present in the ID token'}));}if(!(typeof payload.aud==='string'||Array.isArray(payload.aud))){return Promise.reject(idTokenError({error:'missing_audience_claim',desc:'Audience (aud) claim must be a string or array of strings present in the ID token'}));}if(Array.isArray(payload.aud)&&!payload.aud.includes(opts.clientId)){return Promise.reject(idTokenError({error:'invalid_audience_claim',desc:\"Audience (aud) claim mismatch in the ID token; expected \\\"\"+opts.clientId+\"\\\" but was not one of \\\"\"+payload.aud.join(', ')+\"\\\"\"}));}else if(typeof payload.aud==='string'&&payload.aud!==opts.clientId){return Promise.reject(idTokenError({error:'invalid_audience_claim',desc:\"Audience (aud) claim mismatch in the ID token; expected \\\"\"+opts.clientId+\"\\\" but found \\\"\"+payload.aud+\"\\\"\"}));}var now=opts._clock?getEpochTimeInSeconds(opts._clock):getEpochTimeInSeconds(new Date());var leeway=typeof opts.leeway==='number'?opts.leeway:DEFAULT_LEEWAY;if(typeof payload.exp!=='number'){return Promise.reject(idTokenError({error:'missing_expires_at_claim',desc:'Expiration Time (exp) claim must be a number present in the ID token'}));}var expTime=payload.exp+leeway;if(now>expTime){return Promise.reject(idTokenError({error:'invalid_expires_at_claim',desc:\"Expiration Time (exp) claim error in the ID token; current time \\\"\"+now+\"\\\" is after expiration time \\\"\"+expTime+\"\\\"\"}));}if(typeof payload.iat!=='number'){return Promise.reject(idTokenError({error:'missing_issued_at_claim',desc:'Issued At (iat) claim must be a number present in the ID token'}));}if(opts.nonce){if(typeof payload.nonce!=='string'){return Promise.reject(idTokenError({error:'missing_nonce_claim',desc:'Nonce (nonce) claim must be a string present in the ID token'}));}if(payload.nonce!==opts.nonce){return Promise.reject(idTokenError({error:'invalid_nonce_claim',desc:\"Nonce (nonce) claim mismatch in the ID token; expected \\\"\"+opts.nonce+\"\\\", found \\\"\"+payload.nonce+\"\\\"\"}));}}if(Array.isArray(payload.aud)&&payload.aud.length>1){if(typeof payload.azp!=='string'){return Promise.reject(idTokenError({error:'missing_authorized_party_claim',desc:'Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values'}));}if(payload.azp!==opts.clientId){return Promise.reject(idTokenError({error:'invalid_authorized_party_claim',desc:\"Authorized Party (azp) claim mismatch in the ID token; expected \\\"\"+opts.clientId+\"\\\", found \\\"\"+payload.azp+\"\\\"\"}));}}if(typeof opts.maxAge==='number'){if(typeof payload.auth_time!=='number'){return Promise.reject(idTokenError({error:'missing_authorization_time_claim',desc:'Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified'}));}var authValidUntil=payload.auth_time+opts.maxAge+leeway;if(now>authValidUntil){return Promise.reject(idTokenError({error:'invalid_authorization_time_claim',desc:\"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time \\\"\"+now+\"\\\" is after last auth time \\\"\"+authValidUntil+\"\\\"\"}));}}return Promise.resolve();};var getEpochTimeInSeconds=function getEpochTimeInSeconds(date){return Math.round(date.getTime()/1000);};var idTokenError=function idTokenError(){var _ref=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref$error=_ref.error,error=_ref$error===void 0?'verification_error':_ref$error,_ref$desc=_ref.desc,desc=_ref$desc===void 0?'Error verifying ID token':_ref$desc;return new _authError.default({json:{error:\"a0.idtoken.\"+error,error_description:desc},status:0});};","map":{"version":3,"sources":["/Users/diannamcallister/Desktop/spotstitch/frontend/node_modules/react-native-auth0/src/jwt/validator.js"],"names":["DEFAULT_LEEWAY","verifyToken","idToken","options","Promise","resolve","domain","then","payload","validateClaims","opts","iss","reject","idTokenError","error","desc","sub","aud","Array","isArray","includes","clientId","join","now","_clock","getEpochTimeInSeconds","Date","leeway","exp","expTime","iat","nonce","length","azp","maxAge","auth_time","authValidUntil","date","Math","round","getTime","AuthError","json","error_description","status"],"mappings":"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","sourcesContent":["import AuthError from '../auth/authError';\nimport {verifySignature} from './signatureVerifier';\n\n// default clock skew, in seconds\nconst DEFAULT_LEEWAY = 60;\n\n/**\n * Verifies an ID token according to the OIDC specification. Note that this function is specific to the internals of this SDK,\n * and is not supported for general use.\n * @param {String} idToken the string token to verify\n * @param {Object}options the options required to run this verification\n * @returns {Promise} A promise that resolves if the verification is successful, or will reject the promise if validation fails\n */\nexport const verifyToken = (idToken, options) => {\n  if (typeof idToken !== 'string') {\n    return Promise.resolve();\n  }\n\n  return verifySignature(idToken, {domain: options.domain})\n    .then(payload => validateClaims(payload, options))\n    .then(() => Promise.resolve());\n};\n\nconst validateClaims = (payload, opts) => {\n  // Issuer\n  if (typeof payload.iss !== 'string') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_issuer_claim',\n        desc: 'Issuer (iss) claim must be a string present in the ID token',\n      }),\n    );\n  }\n\n  if (payload.iss !== 'https://' + opts.domain + '/') {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_issuer_claim',\n        desc: `Issuer (iss) claim mismatch in the ID token; expected \"https://${opts.domain}/\", found \"${payload.iss}\"`,\n      }),\n    );\n  }\n\n  // Subject\n  if (typeof payload.sub !== 'string') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_subject_claim',\n        desc: 'Subject (sub) claim must be a string present in the ID token',\n      }),\n    );\n  }\n\n  // Audience\n  if (!(typeof payload.aud === 'string' || Array.isArray(payload.aud))) {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_audience_claim',\n        desc:\n          'Audience (aud) claim must be a string or array of strings present in the ID token',\n      }),\n    );\n  }\n\n  if (Array.isArray(payload.aud) && !payload.aud.includes(opts.clientId)) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_audience_claim',\n        desc: `Audience (aud) claim mismatch in the ID token; expected \"${\n          opts.clientId\n        }\" but was not one of \"${payload.aud.join(', ')}\"`,\n      }),\n    );\n  } else if (typeof payload.aud === 'string' && payload.aud !== opts.clientId) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_audience_claim',\n        desc: `Audience (aud) claim mismatch in the ID token; expected \"${opts.clientId}\" but found \"${payload.aud}\"`,\n      }),\n    );\n  }\n\n  //--Time validation (epoch)--\n  const now = opts._clock\n    ? getEpochTimeInSeconds(opts._clock)\n    : getEpochTimeInSeconds(new Date());\n  const leeway = typeof opts.leeway === 'number' ? opts.leeway : DEFAULT_LEEWAY;\n\n  //Expires at\n  if (typeof payload.exp !== 'number') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_expires_at_claim',\n        desc:\n          'Expiration Time (exp) claim must be a number present in the ID token',\n      }),\n    );\n  }\n\n  const expTime = payload.exp + leeway;\n\n  if (now > expTime) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_expires_at_claim',\n        desc: `Expiration Time (exp) claim error in the ID token; current time \"${now}\" is after expiration time \"${expTime}\"`,\n      }),\n    );\n  }\n\n  //Issued at\n  if (typeof payload.iat !== 'number') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_issued_at_claim',\n        desc: 'Issued At (iat) claim must be a number present in the ID token',\n      }),\n    );\n  }\n\n  //Nonce\n  if (opts.nonce) {\n    if (typeof payload.nonce !== 'string') {\n      return Promise.reject(\n        idTokenError({\n          error: 'missing_nonce_claim',\n          desc: 'Nonce (nonce) claim must be a string present in the ID token',\n        }),\n      );\n    }\n    if (payload.nonce !== opts.nonce) {\n      return Promise.reject(\n        idTokenError({\n          error: 'invalid_nonce_claim',\n          desc: `Nonce (nonce) claim mismatch in the ID token; expected \"${opts.nonce}\", found \"${payload.nonce}\"`,\n        }),\n      );\n    }\n  }\n\n  //Authorized party\n  if (Array.isArray(payload.aud) && payload.aud.length > 1) {\n    if (typeof payload.azp !== 'string') {\n      return Promise.reject(\n        idTokenError({\n          error: 'missing_authorized_party_claim',\n          desc:\n            'Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values',\n        }),\n      );\n    }\n\n    if (payload.azp !== opts.clientId) {\n      return Promise.reject(\n        idTokenError({\n          error: 'invalid_authorized_party_claim',\n          desc: `Authorized Party (azp) claim mismatch in the ID token; expected \"${opts.clientId}\", found \"${payload.azp}\"`,\n        }),\n      );\n    }\n  }\n\n  //Authentication time\n  if (typeof opts.maxAge === 'number') {\n    if (typeof payload.auth_time !== 'number') {\n      return Promise.reject(\n        idTokenError({\n          error: 'missing_authorization_time_claim',\n          desc:\n            'Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified',\n        }),\n      );\n    }\n\n    const authValidUntil = payload.auth_time + opts.maxAge + leeway;\n\n    if (now > authValidUntil) {\n      return Promise.reject(\n        idTokenError({\n          error: 'invalid_authorization_time_claim',\n          desc: `Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time \"${now}\" is after last auth time \"${authValidUntil}\"`,\n        }),\n      );\n    }\n  }\n\n  return Promise.resolve();\n};\n\nconst getEpochTimeInSeconds = date => {\n  return Math.round(date.getTime() / 1000);\n};\n\nconst idTokenError = ({\n  error = 'verification_error',\n  desc = 'Error verifying ID token',\n} = {}) => {\n  return new AuthError({\n    json: {\n      error: `a0.idtoken.${error}`,\n      error_description: desc,\n    },\n    status: 0,\n  });\n};\n"]},"metadata":{},"sourceType":"script"}