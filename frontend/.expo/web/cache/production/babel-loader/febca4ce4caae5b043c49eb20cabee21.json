{"ast":null,"code":"Object.defineProperty(exports,\"__esModule\",{value:true});exports.removeOrientationListener=exports.listenOrientationChange=exports.heightPercentageToDP=exports.widthPercentageToDP=void 0;var _reactNative=require(\"react-native\");var screenWidth=_reactNative.Dimensions.get('window').width;var screenHeight=_reactNative.Dimensions.get('window').height;var widthPercentageToDP=function widthPercentageToDP(widthPercent){var elemWidth=typeof widthPercent===\"number\"?widthPercent:parseFloat(widthPercent);return _reactNative.PixelRatio.roundToNearestPixel(screenWidth*elemWidth/100);};exports.widthPercentageToDP=widthPercentageToDP;var heightPercentageToDP=function heightPercentageToDP(heightPercent){var elemHeight=typeof heightPercent===\"number\"?heightPercent:parseFloat(heightPercent);return _reactNative.PixelRatio.roundToNearestPixel(screenHeight*elemHeight/100);};exports.heightPercentageToDP=heightPercentageToDP;var listenOrientationChange=function listenOrientationChange(that){_reactNative.Dimensions.addEventListener('change',function(newDimensions){screenWidth=newDimensions.window.width;screenHeight=newDimensions.window.height;that.setState({orientation:screenWidth<screenHeight?'portrait':'landscape'});});};exports.listenOrientationChange=listenOrientationChange;var removeOrientationListener=function removeOrientationListener(){_reactNative.Dimensions.removeEventListener('change',function(){});};exports.removeOrientationListener=removeOrientationListener;","map":{"version":3,"sources":["/Users/diannamcallister/Desktop/spotstitch/frontend/node_modules/react-native-responsive-screen/index.js"],"names":["screenWidth","Dimensions","get","width","screenHeight","height","widthPercentageToDP","widthPercent","elemWidth","parseFloat","PixelRatio","roundToNearestPixel","heightPercentageToDP","heightPercent","elemHeight","listenOrientationChange","that","addEventListener","newDimensions","window","setState","orientation","removeOrientationListener","removeEventListener"],"mappings":"2LACA,yCAGA,GAAIA,CAAAA,WAAW,CAAGC,wBAAWC,GAAX,CAAe,QAAf,EAAyBC,KAA3C,CAGA,GAAIC,CAAAA,YAAY,CAAGH,wBAAWC,GAAX,CAAe,QAAf,EAAyBG,MAA5C,CAQA,GAAMC,CAAAA,mBAAmB,CAAG,QAAtBA,CAAAA,mBAAsB,CAAAC,YAAY,CAAI,CAE1C,GAAMC,CAAAA,SAAS,CAAG,MAAOD,CAAAA,YAAP,GAAwB,QAAxB,CAAmCA,YAAnC,CAAkDE,UAAU,CAACF,YAAD,CAA9E,CAIA,MAAOG,yBAAWC,mBAAX,CAA+BX,WAAW,CAAGQ,SAAd,CAA0B,GAAzD,CAAP,CACD,CAPD,C,gDAeA,GAAMI,CAAAA,oBAAoB,CAAG,QAAvBA,CAAAA,oBAAuB,CAAAC,aAAa,CAAI,CAE5C,GAAMC,CAAAA,UAAU,CAAG,MAAOD,CAAAA,aAAP,GAAyB,QAAzB,CAAoCA,aAApC,CAAoDJ,UAAU,CAACI,aAAD,CAAjF,CAIA,MAAOH,yBAAWC,mBAAX,CAA+BP,YAAY,CAAGU,UAAf,CAA4B,GAA3D,CAAP,CACD,CAPD,C,kDAkBA,GAAMC,CAAAA,uBAAuB,CAAG,QAA1BA,CAAAA,uBAA0B,CAAAC,IAAI,CAAI,CACtCf,wBAAWgB,gBAAX,CAA4B,QAA5B,CAAsC,SAAAC,aAAa,CAAI,CAErDlB,WAAW,CAAGkB,aAAa,CAACC,MAAd,CAAqBhB,KAAnC,CACAC,YAAY,CAAGc,aAAa,CAACC,MAAd,CAAqBd,MAApC,CAGAW,IAAI,CAACI,QAAL,CAAc,CACZC,WAAW,CAAErB,WAAW,CAAGI,YAAd,CAA6B,UAA7B,CAA0C,WAD3C,CAAd,EAGD,CATD,EAUD,CAXD,C,wDAmBA,GAAMkB,CAAAA,yBAAyB,CAAG,QAA5BA,CAAAA,yBAA4B,EAAM,CACtCrB,wBAAWsB,mBAAX,CAA+B,QAA/B,CAAyC,UAAM,CAAE,CAAjD,EACD,CAFD,C","sourcesContent":["// packages\nimport { Dimensions, PixelRatio } from 'react-native';\n\n// Retrieve initial screen's width\nlet screenWidth = Dimensions.get('window').width;\n\n// Retrieve initial screen's height\nlet screenHeight = Dimensions.get('window').height;\n\n/**\n * Converts provided width percentage to independent pixel (dp).\n * @param  {string} widthPercent The percentage of screen's width that UI element should cover\n *                               along with the percentage symbol (%).\n * @return {number}              The calculated dp depending on current device's screen width.\n */\nconst widthPercentageToDP = widthPercent => {\n  // Parse string percentage input and convert it to number.\n  const elemWidth = typeof widthPercent === \"number\" ? widthPercent : parseFloat(widthPercent);\n\n  // Use PixelRatio.roundToNearestPixel method in order to round the layout\n  // size (dp) to the nearest one that correspons to an integer number of pixels.\n  return PixelRatio.roundToNearestPixel(screenWidth * elemWidth / 100);\n};\n\n/**\n * Converts provided height percentage to independent pixel (dp).\n * @param  {string} heightPercent The percentage of screen's height that UI element should cover\n *                                along with the percentage symbol (%).\n * @return {number}               The calculated dp depending on current device's screen height.\n */\nconst heightPercentageToDP = heightPercent => {\n  // Parse string percentage input and convert it to number.\n  const elemHeight = typeof heightPercent === \"number\" ? heightPercent : parseFloat(heightPercent);\n\n  // Use PixelRatio.roundToNearestPixel method in order to round the layout\n  // size (dp) to the nearest one that correspons to an integer number of pixels.\n  return PixelRatio.roundToNearestPixel(screenHeight * elemHeight / 100);\n};\n\n/**\n * Event listener function that detects orientation change (every time it occurs) and triggers \n * screen rerendering. It does that, by changing the state of the screen where the function is\n * called. State changing occurs for a new state variable with the name 'orientation' that will\n * always hold the current value of the orientation after the 1st orientation change.\n * Invoke it inside the screen's constructor or in componentDidMount lifecycle method.\n * @param {object} that Screen's class component this variable. The function needs it to\n *                      invoke setState method and trigger screen rerender (this.setState()).\n */\nconst listenOrientationChange = that => {\n  Dimensions.addEventListener('change', newDimensions => {\n    // Retrieve and save new dimensions\n    screenWidth = newDimensions.window.width;\n    screenHeight = newDimensions.window.height;\n\n    // Trigger screen's rerender with a state update of the orientation variable\n    that.setState({\n      orientation: screenWidth < screenHeight ? 'portrait' : 'landscape'\n    });\n  });\n};\n\n/**\n * Wrapper function that removes orientation change listener and should be invoked in\n * componentWillUnmount lifecycle method of every class component (UI screen) that\n * listenOrientationChange function has been invoked. This should be done in order to\n * avoid adding new listeners every time the same component is re-mounted.\n */\nconst removeOrientationListener = () => {\n  Dimensions.removeEventListener('change', () => {});\n};\n\nexport {\n  widthPercentageToDP,\n  heightPercentageToDP,\n  listenOrientationChange,\n  removeOrientationListener\n};\n"]},"metadata":{},"sourceType":"script"}